{"name":"Cosmos-site","tagline":"Jekyll site for cosmos","body":"# COSMOS++\r\nCOSMOS++ is a C++ codebase with a Python wrapper that can be compiled and run to generate astrophysical simulations on unstructured grids with local adaptive mesh refinement.\r\n\r\nFeel free to visit the project's website or repository page for more information.\r\n\r\n## Compiling\r\nCOSMOS++ requires an MPI compiler for C++ such as `mpiCC` or `mpicxx` depending on the compile time environment.\r\n\r\nCOSMOS++ can be compiled by running the Python wrapper script, `cosmos`, at the command line, as such\r\n```\r\npython cosmos main-problem nx ny nz output-dir\r\n```\r\nwhere\r\n```\r\nmain-problem -> name of the problem file to be run\r\nnx -> (optional) number of processors dedicated to computing in the x dimension\r\nny -> (optional) number of processors dedicated to computing in the y dimension\r\nnz -> (optional) number of processors dedicated to computing in the z dimension\r\noutput-dir -> (optional) name of the output directory (default: exe-dir)\r\n```\r\nOnce COSMOS++ is compiled, it immediately begins running the simulation unless the `-c` flag is passed. All object files are stored in the `obj-xxx/` folder, where `xxx` is determined from the local architecture, and will only be regenerated if changes have been made that affect them. Thus, for a 'clean compile,' the `obj-desktop/` and `exe-dir/` directories must first be deleted (this is rarely needed), which can be accomplished with the `gmake clean` command.\r\n\r\nCOSMOS++ recognizes the compile and runtime environments based on OS variables and copies the corresponding Makefile within the `Configure/` directory to the Makefile in the project root. If a specific Makefile cannot be found, the Python wrapper uses `make.desktop`. For personal systems, Mac environments will use `make.mac` and Linux environments will use the default `make.desktop`. There are also Makefiles for various clusters that COSMOS++ has previously been compiled on. If a particular cluster does not have a Makefile and it requires quite a bit of customization, please contribute the resulting Makefile to the repository.\r\n\r\nEach problem has its own main file containing that problem's configuration and initialization. A full list of them can be found within the `Main/` and `MainProjects/` directories in the repository. The main file that is specified at compile time is copied to `main.cc`, which is the file that is actually compiled for the simulation.\r\n\r\n## Viewing Output\r\nThe output of a simulation is contained in the `exe-dir` directory unless specified otherwise during compilation. It is intended to be viewed using visualization software such as VisIt. Other diagnostic files, such as `timings.dat` may also be contained within the output directory.\r\n\r\n## Problem Development\r\nEach problem has its own main file within `Main/` or `MainProjects/` and the file follows this general structure:\r\n\r\n1. Problem configuration (number of zones, stop time, dump intervals, method flags)\r\n2. Initialize MPI\r\n3. Create the mesh\r\n4. Initialize physics packages (primitive solver, HRSC/FEM)\r\n5. Set boundary conditions\r\n6. Prerefine the mesh (if applicable)\r\n7. Set initial data (problem specific)\r\n8. Register fields with solver\r\n9. Register output fields\r\n10. Advance solution\r\nIf you wish to create a new main file, it is recommended that you copy an existing, working main file and edit it, as needed.\r\n\r\n## Project Development\r\n### Folder Structure\r\nAdvect             Advection of all registered fields,\r\n                   options exist for consistent (or not) transport\r\n                   MeshVelocity functions are included in this class,\r\n                   as are artificial and molecular viscosity options.\r\n\r\nBC                 Boundary conditions.\r\n\r\nConfigure          Includes all common and platform-specific make files\r\n                   and scripts (Make.physics) for the specification of\r\n                   package options (e.g., MPI, linearsolver, debug\r\n                   compilation, physics packages to compile).\r\n\r\nCool               Assortment of various cooling functions.\r\n\r\nDocumentation      Articles and text write-ups of the code,\r\n                   installation instructions, and general usage\r\n                   information. Includes Hypre, Visit, Perforce,\r\n                   Totalview, Linux, and Cosmos documentation.\r\n\r\nEOS                Equation of state base and inherited classes.\r\n\r\nField              Responsible for registering all evolved fields, and\r\n                   computing gradients, averaging functions, particle\r\n                   and field exchanges across processors.\r\n\r\nLinearSolver       Includes Hypre, FFT, and other matrix solvers\r\n                   and interfaces.\r\n\r\nMain               Main decks for test problems.\r\n\r\nMainProjects       Main decks for actual production problems.\r\n\r\nMesh               Includes the MPI, zone, mesh, particle, restart, and\r\n                   math abstraction (Tensor, Vector) classes.\r\n\r\nMetric             All metric classes defining the mesh types\r\n                   (e.g., cartesian, spherical, cylindrical\r\n                   Schwarzschild, Kerr, etc...).\r\n\r\nNetwork            Reactive networks.\r\n\r\nOpacity            Opacity base and inherited classes.\r\n\r\nParts              Particle function classes (e.g. geodesics).\r\n\r\nPhysics            Available physics packages.\r\n\r\nPhysicsHelper      Available physics package helpers (e.g., setting up\r\n                   complicated initial data, analytic code tests,\r\n                   etc...).\r\n\r\nPostProcess        Codes for post-processing and analyzing stored data\r\n                   after completion of runs.\r\n\r\nRegressionTests    Includes standard set of tests to be performed each\r\n                   time the code is modified before submission into\r\n                   the code depot. This ensures any newly submitted\r\n                   changes do not break the code.\r\n\r\nScripts            Some useful scripts (e.g., batch submission)\r\n\r\nUtilities          Output dump objects, including time history, 1D line\r\n                   traces, and multi-D HDF5 for visualization (VisIt).\r\n                   Also includes random number generators, timer\r\n                   objects, gravitional wave extraction, mesh\r\n                   refinement, physical constants, and main driver of\r\n                   the code.\r\n\r\n### Code Documentation\r\nCOSMOS++ uses Doxygen to compile code documentation. It must be installed before being able to compile. Here is how to install it on Debian:\r\n```\r\nsudo apt-get install doxygen doxygen-latex doxygen-doc doxygen-gui graphviz\r\n```\r\nThe Doxygen configuration file is called `doxygen-config` and documentation can be generated by running\r\n```\r\ndoxygen doxygen-config\r\n```\r\nin the repository root. This will create the directory `doxygen-docs/` in the project root. COSMOS++ is currently configured to generate both HTML and LaTeX documentation. Visit Doxygen's website for more information on how to document C++ with it.\r\n\r\n### Performance Testing\r\nFor performance testing, objects of the class `Timer` can be registered in `Utilities/TimerList.hh`. Timers can be nested by creating and specifying a parent timer that will keep track of the total time its children have used. For example,\r\n```\r\nTimer TimeGetMagneticField(\"Get Magnetic Field\");\r\nTimer TimeGetMagneticFieldOppZone(\"Get opposite zone\", TimeGetMagneticField);\r\nTimer TimeGetMagneticFieldToFace(\"Projection onto face\", TimeGetMagneticField);\r\n```\r\nwill create two timers and their total time will be kept in the first. The timers must then be declared in the file they will be used in by adding `extern Timer TimerName;` to the file header. The timers can then be started and stopped by calling their `start()` and `stop()` methods. Here is how the previous example's timers would be used to time two blocks of code\r\n```\r\nTimeGetMagneticField.start();\r\n\r\nTimeGetMagneticFieldOppZone.start();\r\ncode code code\r\nTimeGetMagneticFieldOppZone.stop();\r\n\r\nTimeGetMagneticFieldToFace.start();\r\ncode code code\r\nTimeGetMagneticFieldToFace.stop();\r\n\r\nTimeGetMagneticField.stop();\r\n```\r\nAfter a simulation completes, the timings can be found in the file, `timings.dat`, contained within the output directory (default: `exe-dir/`).\r\n\r\n### Regression Testing\r\nRegression tests are contained within the `RegressionTests/` directory and can be run in the same manner as main files. The regression tests in COSMOS++ are typically additional main files that are known to be stable. When adding regression tests, please also add the filename to `listOfTests` that is within the same directory. The full suite of regression tests can be run using the command line\r\n```\r\nrunRegressionTests\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}